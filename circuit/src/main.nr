// ─── AION ZKP — Private Note Membership Circuit ────────────────────────────────
//
// Proves that the prover knows (secret, nullifier) such that:
//
//   1. commitment = Poseidon2(secret, nullifier, denomination_tier)
//      is a leaf in the Merkle tree with the given root.
//
//   2. nullifier_hash = Poseidon2(nullifier)
//      — binds the proof to a specific nullifier without revealing it,
//        allowing the on-chain contract to detect double-spending.
//
//   3. recipient is bound as a public input, preventing frontrunning
//      (the proof is only valid for the address that generated it).
//
// Verified on Starknet via the Garaga UltraKeccakHonk verifier.
//
// Denomination tiers (WBTC, 8 decimals):
//   0 → 0.001 WBTC   (100,000 sat)
//   1 → 0.01  WBTC   (1,000,000 sat)
//   2 → 0.1   WBTC   (10,000,000 sat)
//   3 → 1.0   WBTC   (100,000,000 sat)
//
// The denomination is baked into the commitment so a note cannot be
// redeemed for a different denomination than it was deposited with.
// ─────────────────────────────────────────────────────────────────────────────

use dep::std::hash::poseidon2::Poseidon2;

/// Merkle tree depth — supports 2^20 = 1,048,576 commitments.
global MERKLE_DEPTH: u32 = 20;

/// Compute an incremental Merkle root from a leaf and its authentication path.
/// path_indices[i] = 0 → current node is the LEFT child (sibling goes right)
/// path_indices[i] = 1 → current node is the RIGHT child (sibling goes left)
fn merkle_root(leaf: Field, path: [Field; 20], indices: [u1; 20]) -> Field {
    let mut current = leaf;
    for i in 0..MERKLE_DEPTH {
        let sibling = path[i];
        let is_right = indices[i] as u8 == 1;
        current = if is_right {
            Poseidon2::hash([sibling, current], 2)
        } else {
            Poseidon2::hash([current, sibling], 2)
        };
    }
    current
}

/// Main circuit.
///
/// Private inputs (the witness — never revealed on-chain):
///   secret            — random felt252 generated by the user
///   nullifier         — random felt252 generated by the user
///   merkle_path       — sibling hashes along the path from leaf to root
///   path_indices      — 0=left, 1=right for each level
///
/// Public inputs (appear in the proof and verified by the Garaga contract):
///   root              — current Merkle root stored in PrivacyLayer
///   nullifier_hash    — Poseidon2(nullifier), used for double-spend detection
///   recipient         — Starknet address that will receive the funds
///   denomination_tier — which fixed denomination (0–3) this note represents
fn main(
    // ── Private witness ────────────────────────────────────────────────────
    secret: Field,
    nullifier: Field,
    merkle_path: [Field; 20],
    path_indices: [u1; 20],

    // ── Public statements ──────────────────────────────────────────────────
    root: pub Field,
    nullifier_hash: pub Field,
    recipient: pub Field,
    denomination_tier: pub Field,
) {
    // ── Constraint 1: Commitment integrity ─────────────────────────────────
    //
    // commitment = Poseidon2(secret ‖ nullifier ‖ denomination_tier)
    //
    // Binding denomination_tier into the commitment means a note cannot be
    // redeemed for a different tier than it was committed to, even if the
    // prover knows a valid (secret, nullifier) pair for another tier.
    let commitment = Poseidon2::hash([secret, nullifier, denomination_tier], 3);

    // ── Constraint 2: Merkle membership ────────────────────────────────────
    //
    // Re-derive the root from the commitment and the authentication path.
    // If the re-derived root matches the public `root`, the commitment exists
    // in the tree without revealing its position.
    let derived_root = merkle_root(commitment, merkle_path, path_indices);
    assert(derived_root == root, "Commitment not in Merkle tree");

    // ── Constraint 3: Nullifier hash binding ───────────────────────────────
    //
    // nullifier_hash = Poseidon2(nullifier)
    //
    // The contract stores nullifier_hash as "spent" after withdrawal,
    // preventing the same note from being withdrawn twice.
    // The nullifier itself is never revealed — only its hash is public.
    let expected_nh = Poseidon2::hash([nullifier], 1);
    assert(expected_nh == nullifier_hash, "Nullifier hash mismatch");

    // ── Constraint 4: Recipient binding ────────────────────────────────────
    //
    // `recipient` is a public input, so the proof is cryptographically
    // tied to a specific withdrawal address. This prevents a frontrunner
    // from substituting their own address — the proof would fail to verify
    // with a different recipient field.
    //
    // We add a dummy constraint to force the compiler to include `recipient`
    // in the constraint system (not just as a declared public input).
    let recipient_check = recipient * 1;
    assert(recipient_check == recipient, "Recipient binding");
}
